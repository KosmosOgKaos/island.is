/* tslint:disable */
/* eslint-disable */
/**
 * X-Road Security Server Admin API
 * X-Road Security Server Admin API
 *
 * The version of the OpenAPI document: 1.0.28
 * Contact: info@niis.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    PossibleAction,
    PossibleActionFromJSON,
    PossibleActionToJSON,
    SecurityServerAddress,
    SecurityServerAddressFromJSON,
    SecurityServerAddressToJSON,
    TokenCertificate,
    TokenCertificateFromJSON,
    TokenCertificateToJSON,
} from '../models';

export interface ActivateCertificateRequest {
    hash: string;
}

export interface DeleteCertificateRequest {
    hash: string;
}

export interface DisableCertificateRequest {
    hash: string;
}

export interface GetCertificateRequest {
    hash: string;
}

export interface GetPossibleActionsForCertificateRequest {
    hash: string;
}

export interface ImportCertificateRequest {
    body?: Blob;
}

export interface ImportCertificateFromTokenRequest {
    hash: string;
}

export interface MarkAuthCertForDeletionRequest {
    hash: string;
}

export interface RegisterCertificateRequest {
    hash: string;
    securityServerAddress?: SecurityServerAddress;
}

export interface UnregisterAuthCertificateRequest {
    hash: string;
}

/**
 * 
 */
export class TokenCertificatesApi extends runtime.BaseAPI {

    /**
     * Administrator activates selected certificate.
     * activate certificate
     */
    async activateCertificateRaw(requestParameters: ActivateCertificateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling activateCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}/activate`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator activates selected certificate.
     * activate certificate
     */
    async activateCertificate(requestParameters: ActivateCertificateRequest): Promise<void> {
        await this.activateCertificateRaw(requestParameters);
    }

    /**
     * Administrator deletes the certificate.
     * delete certificate
     */
    async deleteCertificateRaw(requestParameters: DeleteCertificateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling deleteCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator deletes the certificate.
     * delete certificate
     */
    async deleteCertificate(requestParameters: DeleteCertificateRequest): Promise<void> {
        await this.deleteCertificateRaw(requestParameters);
    }

    /**
     * Administrator deactivates selected certificate.
     * deactivate certificate
     */
    async disableCertificateRaw(requestParameters: DisableCertificateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling disableCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}/disable`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator deactivates selected certificate.
     * deactivate certificate
     */
    async disableCertificate(requestParameters: DisableCertificateRequest): Promise<void> {
        await this.disableCertificateRaw(requestParameters);
    }

    /**
     * Administrator views certificate details.
     * get certificate information
     */
    async getCertificateRaw(requestParameters: GetCertificateRequest): Promise<runtime.ApiResponse<TokenCertificate>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling getCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenCertificateFromJSON(jsonValue));
    }

    /**
     * Administrator views certificate details.
     * get certificate information
     */
    async getCertificate(requestParameters: GetCertificateRequest): Promise<TokenCertificate> {
        const response = await this.getCertificateRaw(requestParameters);
        return await response.value();
    }

    /**
     * UI needs to know which actions can be done on one certificate
     * get possible actions for one certificate
     */
    async getPossibleActionsForCertificateRaw(requestParameters: GetPossibleActionsForCertificateRequest): Promise<runtime.ApiResponse<Array<PossibleAction>>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling getPossibleActionsForCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}/possible-actions`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PossibleActionFromJSON));
    }

    /**
     * UI needs to know which actions can be done on one certificate
     * get possible actions for one certificate
     */
    async getPossibleActionsForCertificate(requestParameters: GetPossibleActionsForCertificateRequest): Promise<Array<PossibleAction>> {
        const response = await this.getPossibleActionsForCertificateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Imports certificate to the system
     * import new certificate
     */
    async importCertificateRaw(requestParameters: ImportCertificateRequest): Promise<runtime.ApiResponse<TokenCertificate>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenCertificateFromJSON(jsonValue));
    }

    /**
     * Imports certificate to the system
     * import new certificate
     */
    async importCertificate(requestParameters: ImportCertificateRequest): Promise<TokenCertificate> {
        const response = await this.importCertificateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Imports certificate from a token to the system
     * import an existing certificate from a token by cert hash
     */
    async importCertificateFromTokenRaw(requestParameters: ImportCertificateFromTokenRequest): Promise<runtime.ApiResponse<TokenCertificate>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling importCertificateFromToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}/import`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenCertificateFromJSON(jsonValue));
    }

    /**
     * Imports certificate from a token to the system
     * import an existing certificate from a token by cert hash
     */
    async importCertificateFromToken(requestParameters: ImportCertificateFromTokenRequest): Promise<TokenCertificate> {
        const response = await this.importCertificateFromTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator marks an auth certificate for deletion.
     * marks an auth certificate for deletion
     */
    async markAuthCertForDeletionRaw(requestParameters: MarkAuthCertForDeletionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling markAuthCertForDeletion.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}/mark-for-deletion`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator marks an auth certificate for deletion.
     * marks an auth certificate for deletion
     */
    async markAuthCertForDeletion(requestParameters: MarkAuthCertForDeletionRequest): Promise<void> {
        await this.markAuthCertForDeletionRaw(requestParameters);
    }

    /**
     * Administrator registers selected certificate.
     * register certificate
     */
    async registerCertificateRaw(requestParameters: RegisterCertificateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling registerCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}/register`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SecurityServerAddressToJSON(requestParameters.securityServerAddress),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator registers selected certificate.
     * register certificate
     */
    async registerCertificate(requestParameters: RegisterCertificateRequest): Promise<void> {
        await this.registerCertificateRaw(requestParameters);
    }

    /**
     * Administrator unregisters selected authentication certificate.
     * unregister authentication certificate
     */
    async unregisterAuthCertificateRaw(requestParameters: UnregisterAuthCertificateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling unregisterAuthCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/token-certificates/{hash}/unregister`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator unregisters selected authentication certificate.
     * unregister authentication certificate
     */
    async unregisterAuthCertificate(requestParameters: UnregisterAuthCertificateRequest): Promise<void> {
        await this.unregisterAuthCertificateRaw(requestParameters);
    }

}

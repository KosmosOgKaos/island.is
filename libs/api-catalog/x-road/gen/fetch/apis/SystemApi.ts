/* tslint:disable */
/* eslint-disable */
/**
 * X-Road Security Server Admin API
 * X-Road Security Server Admin API
 *
 * The version of the OpenAPI document: 1.0.28
 * Contact: info@niis.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Anchor,
    AnchorFromJSON,
    AnchorToJSON,
    CertificateDetails,
    CertificateDetailsFromJSON,
    CertificateDetailsToJSON,
    DistinguishedName,
    DistinguishedNameFromJSON,
    DistinguishedNameToJSON,
    TimestampingService,
    TimestampingServiceFromJSON,
    TimestampingServiceToJSON,
    Version,
    VersionFromJSON,
    VersionToJSON,
} from '../models';

export interface AddConfiguredTimestampingServiceRequest {
    timestampingService?: TimestampingService;
}

export interface DeleteConfiguredTimestampingServiceRequest {
    timestampingService?: TimestampingService;
}

export interface GenerateSystemCertificateRequestRequest {
    distinguishedName?: DistinguishedName;
}

export interface ImportSystemCertificateRequest {
    body?: Blob;
}

export interface PreviewAnchorRequest {
    validateInstance?: boolean;
    body?: Blob;
}

export interface ReplaceAnchorRequest {
    body?: Blob;
}

export interface UploadInitialAnchorRequest {
    body?: Blob;
}

/**
 * 
 */
export class SystemApi extends runtime.BaseAPI {

    /**
     * Administrator selects new timestamping service
     * add a configured timestamping service
     */
    async addConfiguredTimestampingServiceRaw(requestParameters: AddConfiguredTimestampingServiceRequest): Promise<runtime.ApiResponse<TimestampingService>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/timestamping-services`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TimestampingServiceToJSON(requestParameters.timestampingService),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TimestampingServiceFromJSON(jsonValue));
    }

    /**
     * Administrator selects new timestamping service
     * add a configured timestamping service
     */
    async addConfiguredTimestampingService(requestParameters: AddConfiguredTimestampingServiceRequest): Promise<TimestampingService> {
        const response = await this.addConfiguredTimestampingServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator removes configured timestamping service.
     * delete configured timestamping service
     */
    async deleteConfiguredTimestampingServiceRaw(requestParameters: DeleteConfiguredTimestampingServiceRequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/timestamping-services/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TimestampingServiceToJSON(requestParameters.timestampingService),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator removes configured timestamping service.
     * delete configured timestamping service
     */
    async deleteConfiguredTimestampingService(requestParameters: DeleteConfiguredTimestampingServiceRequest): Promise<void> {
        await this.deleteConfiguredTimestampingServiceRaw(requestParameters);
    }

    /**
     * Administrator downloads the configuration anchor information.
     * download configuration anchor information
     */
    async downloadAnchorRaw(): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/anchor/download`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Administrator downloads the configuration anchor information.
     * download configuration anchor information
     */
    async downloadAnchor(): Promise<Blob> {
        const response = await this.downloadAnchorRaw();
        return await response.value();
    }

    /**
     * Administrator downloads the security server TLS certificate.
     * download the security server certificate as gzip compressed tar archive
     */
    async downloadSystemCertificateRaw(): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/certificate/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Administrator downloads the security server TLS certificate.
     * download the security server certificate as gzip compressed tar archive
     */
    async downloadSystemCertificate(): Promise<Blob> {
        const response = await this.downloadSystemCertificateRaw();
        return await response.value();
    }

    /**
     * Administrator generates new certificate request.
     * generate new certificate request
     */
    async generateSystemCertificateRequestRaw(requestParameters: GenerateSystemCertificateRequestRequest): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/certificate/csr`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DistinguishedNameToJSON(requestParameters.distinguishedName),
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Administrator generates new certificate request.
     * generate new certificate request
     */
    async generateSystemCertificateRequest(requestParameters: GenerateSystemCertificateRequestRequest): Promise<Blob> {
        const response = await this.generateSystemCertificateRequestRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator generates new internal TLS key and certificate
     * generate a new internal TLS key and cert
     */
    async generateSystemTlsKeyAndCertificateRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/certificate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator generates new internal TLS key and certificate
     * generate a new internal TLS key and cert
     */
    async generateSystemTlsKeyAndCertificate(): Promise<void> {
        await this.generateSystemTlsKeyAndCertificateRaw();
    }

    /**
     * Administrator views the configuration anchor information.
     * view the configuration anchor information
     */
    async getAnchorRaw(): Promise<runtime.ApiResponse<Anchor>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/anchor`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnchorFromJSON(jsonValue));
    }

    /**
     * Administrator views the configuration anchor information.
     * view the configuration anchor information
     */
    async getAnchor(): Promise<Anchor> {
        const response = await this.getAnchorRaw();
        return await response.value();
    }

    /**
     * Administrator views the configured timestamping services.
     * view the configured timestamping services
     */
    async getConfiguredTimestampingServicesRaw(): Promise<runtime.ApiResponse<Array<TimestampingService>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/timestamping-services`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TimestampingServiceFromJSON));
    }

    /**
     * Administrator views the configured timestamping services.
     * view the configured timestamping services
     */
    async getConfiguredTimestampingServices(): Promise<Array<TimestampingService>> {
        const response = await this.getConfiguredTimestampingServicesRaw();
        return await response.value();
    }

    /**
     * Administrator views the security server TLS certificate information.
     * view the security server certificate information
     */
    async getSystemCertificateRaw(): Promise<runtime.ApiResponse<CertificateDetails>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/certificate`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateDetailsFromJSON(jsonValue));
    }

    /**
     * Administrator views the security server TLS certificate information.
     * view the security server certificate information
     */
    async getSystemCertificate(): Promise<CertificateDetails> {
        const response = await this.getSystemCertificateRaw();
        return await response.value();
    }

    /**
     * Administrator imports new internal TLS certificate
     * import new internal TLS certificate.
     */
    async importSystemCertificateRaw(requestParameters: ImportSystemCertificateRequest): Promise<runtime.ApiResponse<CertificateDetails>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/certificate/import`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateDetailsFromJSON(jsonValue));
    }

    /**
     * Administrator imports new internal TLS certificate
     * import new internal TLS certificate.
     */
    async importSystemCertificate(requestParameters: ImportSystemCertificateRequest): Promise<CertificateDetails> {
        const response = await this.importSystemCertificateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator wants to preview a configuration anchor file hash
     * Read and the configuration anchor file and return the hash for a preview. The instance of the anchor is also validated unless the validate_instance query parameter is explicitly set to false. The anchor will not be saved
     */
    async previewAnchorRaw(requestParameters: PreviewAnchorRequest): Promise<runtime.ApiResponse<Anchor>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.validateInstance !== undefined) {
            queryParameters['validate_instance'] = requestParameters.validateInstance;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/anchor/previews`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnchorFromJSON(jsonValue));
    }

    /**
     * Administrator wants to preview a configuration anchor file hash
     * Read and the configuration anchor file and return the hash for a preview. The instance of the anchor is also validated unless the validate_instance query parameter is explicitly set to false. The anchor will not be saved
     */
    async previewAnchor(requestParameters: PreviewAnchorRequest): Promise<Anchor> {
        const response = await this.previewAnchorRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator uploads a configuration anchor file anytime after the Security Server has been initialized
     * Upload a configuration anchor file to replace an existing one. Note that this only works if there already exists an anchor that can be replaced. When initalizing a new Security Server use endpoint POST /system/anchor instead
     */
    async replaceAnchorRaw(requestParameters: ReplaceAnchorRequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/anchor`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator uploads a configuration anchor file anytime after the Security Server has been initialized
     * Upload a configuration anchor file to replace an existing one. Note that this only works if there already exists an anchor that can be replaced. When initalizing a new Security Server use endpoint POST /system/anchor instead
     */
    async replaceAnchor(requestParameters: ReplaceAnchorRequest): Promise<void> {
        await this.replaceAnchorRaw(requestParameters);
    }

    /**
     * Administrator views key details.
     * get information for the system version
     */
    async systemVersionRaw(): Promise<runtime.ApiResponse<Version>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFromJSON(jsonValue));
    }

    /**
     * Administrator views key details.
     * get information for the system version
     */
    async systemVersion(): Promise<Version> {
        const response = await this.systemVersionRaw();
        return await response.value();
    }

    /**
     * Administrator uploads a new configuration anchor file in the security server\'s initialization phase
     * Upload a new configuration anchor file when initializing a new security server. Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that this endpoint can only be used when initializing a new security server. For updating the anchor for an already initialized security server use the PUT /system/anchor endpoint instead
     */
    async uploadInitialAnchorRaw(requestParameters: UploadInitialAnchorRequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/system/anchor`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator uploads a new configuration anchor file in the security server\'s initialization phase
     * Upload a new configuration anchor file when initializing a new security server. Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that this endpoint can only be used when initializing a new security server. For updating the anchor for an already initialized security server use the PUT /system/anchor endpoint instead
     */
    async uploadInitialAnchor(requestParameters: UploadInitialAnchorRequest): Promise<void> {
        await this.uploadInitialAnchorRaw(requestParameters);
    }

}

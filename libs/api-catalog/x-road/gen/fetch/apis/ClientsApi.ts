/* tslint:disable */
/* eslint-disable */
/**
 * X-Road Security Server Admin API
 * X-Road Security Server Admin API
 *
 * The version of the OpenAPI document: 1.0.28
 * Contact: info@niis.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AccessRight,
    AccessRightFromJSON,
    AccessRightToJSON,
    AccessRights,
    AccessRightsFromJSON,
    AccessRightsToJSON,
    CertificateDetails,
    CertificateDetailsFromJSON,
    CertificateDetailsToJSON,
    Client,
    ClientFromJSON,
    ClientToJSON,
    ClientAdd,
    ClientAddFromJSON,
    ClientAddToJSON,
    ConnectionTypeWrapper,
    ConnectionTypeWrapperFromJSON,
    ConnectionTypeWrapperToJSON,
    ErrorInfo,
    ErrorInfoFromJSON,
    ErrorInfoToJSON,
    LocalGroup,
    LocalGroupFromJSON,
    LocalGroupToJSON,
    LocalGroupAdd,
    LocalGroupAddFromJSON,
    LocalGroupAddToJSON,
    OrphanInformation,
    OrphanInformationFromJSON,
    OrphanInformationToJSON,
    ServiceClient,
    ServiceClientFromJSON,
    ServiceClientToJSON,
    ServiceClientType,
    ServiceClientTypeFromJSON,
    ServiceClientTypeToJSON,
    ServiceDescription,
    ServiceDescriptionFromJSON,
    ServiceDescriptionToJSON,
    ServiceDescriptionAdd,
    ServiceDescriptionAddFromJSON,
    ServiceDescriptionAddToJSON,
    TokenCertificate,
    TokenCertificateFromJSON,
    TokenCertificateToJSON,
} from '../models';

export interface AddClientRequest {
    clientAdd?: ClientAdd;
}

export interface AddClientLocalGroupRequest {
    id: string;
    localGroupAdd?: LocalGroupAdd;
}

export interface AddClientServiceDescriptionRequest {
    id: string;
    serviceDescriptionAdd?: ServiceDescriptionAdd;
}

export interface AddClientTlsCertificateRequest {
    id: string;
    body?: Blob;
}

export interface AddServiceClientAccessRightsRequest {
    id: string;
    scId: string;
    accessRights?: AccessRights;
}

export interface ChangeOwnerRequest {
    id: string;
}

export interface DeleteClientRequest {
    id: string;
}

export interface DeleteClientTlsCertificateRequest {
    id: string;
    hash: string;
}

export interface DeleteOrphansRequest {
    id: string;
}

export interface DeleteServiceClientAccessRightsRequest {
    id: string;
    scId: string;
    accessRights?: AccessRights;
}

export interface FindClientsRequest {
    name?: string;
    instance?: string;
    memberClass?: string;
    memberCode?: string;
    subsystemCode?: string;
    showMembers?: boolean;
    internalSearch?: boolean;
    localValidSignCert?: boolean;
    excludeLocal?: boolean;
}

export interface FindServiceClientCandidatesRequest {
    id: string;
    memberNameGroupDescription?: string;
    serviceClientType?: ServiceClientType;
    instance?: string;
    memberClass?: string;
    memberGroupCode?: string;
    subsystemCode?: string;
}

export interface GetClientRequest {
    id: string;
}

export interface GetClientLocalGroupsRequest {
    id: string;
}

export interface GetClientOrphansRequest {
    id: string;
}

export interface GetClientServiceClientsRequest {
    id: string;
}

export interface GetClientServiceDescriptionsRequest {
    id: string;
}

export interface GetClientSignCertificatesRequest {
    id: string;
}

export interface GetClientTlsCertificateRequest {
    id: string;
    hash: string;
}

export interface GetClientTlsCertificatesRequest {
    id: string;
}

export interface GetServiceClientRequest {
    id: string;
    scId: string;
}

export interface GetServiceClientAccessRightsRequest {
    id: string;
    scId: string;
}

export interface RegisterClientRequest {
    id: string;
}

export interface UnregisterClientRequest {
    id: string;
}

export interface UpdateClientRequest {
    id: string;
    connectionTypeWrapper?: ConnectionTypeWrapper;
}

/**
 * 
 */
export class ClientsApi extends runtime.BaseAPI {

    /**
     * Adds new client to the system. Note that with this endpoint it is possible to add an unregistered member as a client. Attempt to add an unregistered member with ClientAdd.ignore_warnings = false causes the operation to fail with a warning in response\'s ErrorInfo object. Attempt to add an unregistered member with ClientAdd.ignore_warnings = true succeeds. 
     * Add new client for the security server.
     */
    async addClientRaw(requestParameters: AddClientRequest): Promise<runtime.ApiResponse<Client>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ClientAddToJSON(requestParameters.clientAdd),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientFromJSON(jsonValue));
    }

    /**
     * Adds new client to the system. Note that with this endpoint it is possible to add an unregistered member as a client. Attempt to add an unregistered member with ClientAdd.ignore_warnings = false causes the operation to fail with a warning in response\'s ErrorInfo object. Attempt to add an unregistered member with ClientAdd.ignore_warnings = true succeeds. 
     * Add new client for the security server.
     */
    async addClient(requestParameters: AddClientRequest): Promise<Client> {
        const response = await this.addClientRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator adds a new local group for the client.
     * add new local group for the security server client
     */
    async addClientLocalGroupRaw(requestParameters: AddClientLocalGroupRequest): Promise<runtime.ApiResponse<LocalGroup>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling addClientLocalGroup.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/local-groups`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocalGroupAddToJSON(requestParameters.localGroupAdd),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LocalGroupFromJSON(jsonValue));
    }

    /**
     * Administrator adds a new local group for the client.
     * add new local group for the security server client
     */
    async addClientLocalGroup(requestParameters: AddClientLocalGroupRequest): Promise<LocalGroup> {
        const response = await this.addClientLocalGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator adds a new service description for the client.
     * add new service description for the security server client
     */
    async addClientServiceDescriptionRaw(requestParameters: AddClientServiceDescriptionRequest): Promise<runtime.ApiResponse<ServiceDescription>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling addClientServiceDescription.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-descriptions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ServiceDescriptionAddToJSON(requestParameters.serviceDescriptionAdd),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ServiceDescriptionFromJSON(jsonValue));
    }

    /**
     * Administrator adds a new service description for the client.
     * add new service description for the security server client
     */
    async addClientServiceDescription(requestParameters: AddClientServiceDescriptionRequest): Promise<ServiceDescription> {
        const response = await this.addClientServiceDescriptionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator adds a new certificate for the client.
     * add new certificate for the security server client
     */
    async addClientTlsCertificateRaw(requestParameters: AddClientTlsCertificateRequest): Promise<runtime.ApiResponse<CertificateDetails>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling addClientTlsCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/tls-certificates`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateDetailsFromJSON(jsonValue));
    }

    /**
     * Administrator adds a new certificate for the client.
     * add new certificate for the security server client
     */
    async addClientTlsCertificate(requestParameters: AddClientTlsCertificateRequest): Promise<CertificateDetails> {
        const response = await this.addClientTlsCertificateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Adds access rights to the service client.
     * add new access rights for selected service client. If service client did not exist yet, one is created.
     */
    async addServiceClientAccessRightsRaw(requestParameters: AddServiceClientAccessRightsRequest): Promise<runtime.ApiResponse<Array<AccessRight>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling addServiceClientAccessRights.');
        }

        if (requestParameters.scId === null || requestParameters.scId === undefined) {
            throw new runtime.RequiredError('scId','Required parameter requestParameters.scId was null or undefined when calling addServiceClientAccessRights.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-clients/{sc_id}/access-rights`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"sc_id"}}`, encodeURIComponent(String(requestParameters.scId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccessRightsToJSON(requestParameters.accessRights),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccessRightFromJSON));
    }

    /**
     * Adds access rights to the service client.
     * add new access rights for selected service client. If service client did not exist yet, one is created.
     */
    async addServiceClientAccessRights(requestParameters: AddServiceClientAccessRightsRequest): Promise<Array<AccessRight>> {
        const response = await this.addServiceClientAccessRightsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator changes Security Server\'s owner.
     * make client Security Server\'s owner. Client must be a member and already registered on the Security Server
     */
    async changeOwnerRaw(requestParameters: ChangeOwnerRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling changeOwner.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/make-owner`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator changes Security Server\'s owner.
     * make client Security Server\'s owner. Client must be a member and already registered on the Security Server
     */
    async changeOwner(requestParameters: ChangeOwnerRequest): Promise<void> {
        await this.changeOwnerRaw(requestParameters);
    }

    /**
     * Administrator deletes the client of the security server.
     * delete security server client
     */
    async deleteClientRaw(requestParameters: DeleteClientRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteClient.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator deletes the client of the security server.
     * delete security server client
     */
    async deleteClient(requestParameters: DeleteClientRequest): Promise<void> {
        await this.deleteClientRaw(requestParameters);
    }

    /**
     * Administrator deletes the certificate from selected client.
     * delete certificate
     */
    async deleteClientTlsCertificateRaw(requestParameters: DeleteClientTlsCertificateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteClientTlsCertificate.');
        }

        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling deleteClientTlsCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/tls-certificates/{hash}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator deletes the certificate from selected client.
     * delete certificate
     */
    async deleteClientTlsCertificate(requestParameters: DeleteClientTlsCertificateRequest): Promise<void> {
        await this.deleteClientTlsCertificateRaw(requestParameters);
    }

    /**
     * Administrator deletes the orphaned sign keys, certificates and csrs left behind a delete client.
     * delete orphaned sign keys, certificates and csrs left behind a delete client
     */
    async deleteOrphansRaw(requestParameters: DeleteOrphansRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteOrphans.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/orphans`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator deletes the orphaned sign keys, certificates and csrs left behind a delete client.
     * delete orphaned sign keys, certificates and csrs left behind a delete client
     */
    async deleteOrphans(requestParameters: DeleteOrphansRequest): Promise<void> {
        await this.deleteOrphansRaw(requestParameters);
    }

    /**
     * Administrator removes access rights from selected service client.
     * remove access rights
     */
    async deleteServiceClientAccessRightsRaw(requestParameters: DeleteServiceClientAccessRightsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteServiceClientAccessRights.');
        }

        if (requestParameters.scId === null || requestParameters.scId === undefined) {
            throw new runtime.RequiredError('scId','Required parameter requestParameters.scId was null or undefined when calling deleteServiceClientAccessRights.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-clients/{sc_id}/access-rights/delete`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"sc_id"}}`, encodeURIComponent(String(requestParameters.scId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccessRightsToJSON(requestParameters.accessRights),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator removes access rights from selected service client.
     * remove access rights
     */
    async deleteServiceClientAccessRights(requestParameters: DeleteServiceClientAccessRightsRequest): Promise<void> {
        await this.deleteServiceClientAccessRightsRaw(requestParameters);
    }

    /**
     * Administrator views the clients of the security server.
     * find security server clients
     */
    async findClientsRaw(requestParameters: FindClientsRequest): Promise<runtime.ApiResponse<Array<Client>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.instance !== undefined) {
            queryParameters['instance'] = requestParameters.instance;
        }

        if (requestParameters.memberClass !== undefined) {
            queryParameters['member_class'] = requestParameters.memberClass;
        }

        if (requestParameters.memberCode !== undefined) {
            queryParameters['member_code'] = requestParameters.memberCode;
        }

        if (requestParameters.subsystemCode !== undefined) {
            queryParameters['subsystem_code'] = requestParameters.subsystemCode;
        }

        if (requestParameters.showMembers !== undefined) {
            queryParameters['show_members'] = requestParameters.showMembers;
        }

        if (requestParameters.internalSearch !== undefined) {
            queryParameters['internal_search'] = requestParameters.internalSearch;
        }

        if (requestParameters.localValidSignCert !== undefined) {
            queryParameters['local_valid_sign_cert'] = requestParameters.localValidSignCert;
        }

        if (requestParameters.excludeLocal !== undefined) {
            queryParameters['exclude_local'] = requestParameters.excludeLocal;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClientFromJSON));
    }

    /**
     * Administrator views the clients of the security server.
     * find security server clients
     */
    async findClients(requestParameters: FindClientsRequest): Promise<Array<Client>> {
        const response = await this.findClientsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the clients, globalgroups and localgroups, that could be added as ServiceClients for given Client\'s services
     * find ServiceClient candidates for a specific client
     */
    async findServiceClientCandidatesRaw(requestParameters: FindServiceClientCandidatesRequest): Promise<runtime.ApiResponse<Array<ServiceClient>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling findServiceClientCandidates.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.memberNameGroupDescription !== undefined) {
            queryParameters['member_name_group_description'] = requestParameters.memberNameGroupDescription;
        }

        if (requestParameters.serviceClientType !== undefined) {
            queryParameters['service_client_type'] = requestParameters.serviceClientType;
        }

        if (requestParameters.instance !== undefined) {
            queryParameters['instance'] = requestParameters.instance;
        }

        if (requestParameters.memberClass !== undefined) {
            queryParameters['member_class'] = requestParameters.memberClass;
        }

        if (requestParameters.memberGroupCode !== undefined) {
            queryParameters['member_group_code'] = requestParameters.memberGroupCode;
        }

        if (requestParameters.subsystemCode !== undefined) {
            queryParameters['subsystem_code'] = requestParameters.subsystemCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-client-candidates`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ServiceClientFromJSON));
    }

    /**
     * Administrator views the clients, globalgroups and localgroups, that could be added as ServiceClients for given Client\'s services
     * find ServiceClient candidates for a specific client
     */
    async findServiceClientCandidates(requestParameters: FindServiceClientCandidatesRequest): Promise<Array<ServiceClient>> {
        const response = await this.findServiceClientCandidatesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the client details of the security server.
     * get security server client information
     */
    async getClientRaw(requestParameters: GetClientRequest): Promise<runtime.ApiResponse<Client>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClient.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientFromJSON(jsonValue));
    }

    /**
     * Administrator views the client details of the security server.
     * get security server client information
     */
    async getClient(requestParameters: GetClientRequest): Promise<Client> {
        const response = await this.getClientRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the local groups for the client.
     * get local groups for the selected client
     */
    async getClientLocalGroupsRaw(requestParameters: GetClientLocalGroupsRequest): Promise<runtime.ApiResponse<Array<LocalGroup>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClientLocalGroups.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/local-groups`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LocalGroupFromJSON));
    }

    /**
     * Administrator views the local groups for the client.
     * get local groups for the selected client
     */
    async getClientLocalGroups(requestParameters: GetClientLocalGroupsRequest): Promise<Array<LocalGroup>> {
        const response = await this.getClientLocalGroupsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator has deleted a client and wants to know if some orphaned sign keys, certificates or csrs exist
     * get information about orphaned sign keys, certificates and csrs left behind a delete client
     */
    async getClientOrphansRaw(requestParameters: GetClientOrphansRequest): Promise<runtime.ApiResponse<OrphanInformation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClientOrphans.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/orphans`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OrphanInformationFromJSON(jsonValue));
    }

    /**
     * Administrator has deleted a client and wants to know if some orphaned sign keys, certificates or csrs exist
     * get information about orphaned sign keys, certificates and csrs left behind a delete client
     */
    async getClientOrphans(requestParameters: GetClientOrphansRequest): Promise<OrphanInformation> {
        const response = await this.getClientOrphansRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the service clients for the client.
     * get service clients for the selected client\'s services
     */
    async getClientServiceClientsRaw(requestParameters: GetClientServiceClientsRequest): Promise<runtime.ApiResponse<Array<ServiceClient>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClientServiceClients.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-clients`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ServiceClientFromJSON));
    }

    /**
     * Administrator views the service clients for the client.
     * get service clients for the selected client\'s services
     */
    async getClientServiceClients(requestParameters: GetClientServiceClientsRequest): Promise<Array<ServiceClient>> {
        const response = await this.getClientServiceClientsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the service descriptions for the client.
     * get security server client service descriptions
     */
    async getClientServiceDescriptionsRaw(requestParameters: GetClientServiceDescriptionsRequest): Promise<runtime.ApiResponse<Array<ServiceDescription>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClientServiceDescriptions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-descriptions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ServiceDescriptionFromJSON));
    }

    /**
     * Administrator views the service descriptions for the client.
     * get security server client service descriptions
     */
    async getClientServiceDescriptions(requestParameters: GetClientServiceDescriptionsRequest): Promise<Array<ServiceDescription>> {
        const response = await this.getClientServiceDescriptionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the certificates for the client.
     * get security server client certificates information
     */
    async getClientSignCertificatesRaw(requestParameters: GetClientSignCertificatesRequest): Promise<runtime.ApiResponse<Array<TokenCertificate>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClientSignCertificates.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/sign-certificates`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenCertificateFromJSON));
    }

    /**
     * Administrator views the certificates for the client.
     * get security server client certificates information
     */
    async getClientSignCertificates(requestParameters: GetClientSignCertificatesRequest): Promise<Array<TokenCertificate>> {
        const response = await this.getClientSignCertificatesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator gets the TLS certificate for the selected client.
     * get TLS certificate
     */
    async getClientTlsCertificateRaw(requestParameters: GetClientTlsCertificateRequest): Promise<runtime.ApiResponse<CertificateDetails>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClientTlsCertificate.');
        }

        if (requestParameters.hash === null || requestParameters.hash === undefined) {
            throw new runtime.RequiredError('hash','Required parameter requestParameters.hash was null or undefined when calling getClientTlsCertificate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/tls-certificates/{hash}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateDetailsFromJSON(jsonValue));
    }

    /**
     * Administrator gets the TLS certificate for the selected client.
     * get TLS certificate
     */
    async getClientTlsCertificate(requestParameters: GetClientTlsCertificateRequest): Promise<CertificateDetails> {
        const response = await this.getClientTlsCertificateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the TLS certificates for the client.
     * get security server client TLS certificates information
     */
    async getClientTlsCertificatesRaw(requestParameters: GetClientTlsCertificatesRequest): Promise<runtime.ApiResponse<Array<CertificateDetails>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClientTlsCertificates.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/tls-certificates`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CertificateDetailsFromJSON));
    }

    /**
     * Administrator views the TLS certificates for the client.
     * get security server client TLS certificates information
     */
    async getClientTlsCertificates(requestParameters: GetClientTlsCertificatesRequest): Promise<Array<CertificateDetails>> {
        const response = await this.getClientTlsCertificatesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views the information for a single service client
     * get single service client by client id and service client id
     */
    async getServiceClientRaw(requestParameters: GetServiceClientRequest): Promise<runtime.ApiResponse<ServiceClient>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getServiceClient.');
        }

        if (requestParameters.scId === null || requestParameters.scId === undefined) {
            throw new runtime.RequiredError('scId','Required parameter requestParameters.scId was null or undefined when calling getServiceClient.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-clients/{sc_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"sc_id"}}`, encodeURIComponent(String(requestParameters.scId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ServiceClientFromJSON(jsonValue));
    }

    /**
     * Administrator views the information for a single service client
     * get single service client by client id and service client id
     */
    async getServiceClient(requestParameters: GetServiceClientRequest): Promise<ServiceClient> {
        const response = await this.getServiceClientRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator views service client\'s access rights.
     * get access rights for the selected service client.
     */
    async getServiceClientAccessRightsRaw(requestParameters: GetServiceClientAccessRightsRequest): Promise<runtime.ApiResponse<Array<AccessRight>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getServiceClientAccessRights.');
        }

        if (requestParameters.scId === null || requestParameters.scId === undefined) {
            throw new runtime.RequiredError('scId','Required parameter requestParameters.scId was null or undefined when calling getServiceClientAccessRights.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/service-clients/{sc_id}/access-rights`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"sc_id"}}`, encodeURIComponent(String(requestParameters.scId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccessRightFromJSON));
    }

    /**
     * Administrator views service client\'s access rights.
     * get access rights for the selected service client.
     */
    async getServiceClientAccessRights(requestParameters: GetServiceClientAccessRightsRequest): Promise<Array<AccessRight>> {
        const response = await this.getServiceClientAccessRightsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Administrator registers client.
     * register security server client
     */
    async registerClientRaw(requestParameters: RegisterClientRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling registerClient.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/register`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator registers client.
     * register security server client
     */
    async registerClient(requestParameters: RegisterClientRequest): Promise<void> {
        await this.registerClientRaw(requestParameters);
    }

    /**
     * Administrator unregisters client.
     * unregister security server client
     */
    async unregisterClientRaw(requestParameters: UnregisterClientRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling unregisterClient.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}/unregister`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Administrator unregisters client.
     * unregister security server client
     */
    async unregisterClient(requestParameters: UnregisterClientRequest): Promise<void> {
        await this.unregisterClientRaw(requestParameters);
    }

    /**
     * Administrator updates the client information.
     * update security server client information
     */
    async updateClientRaw(requestParameters: UpdateClientRequest): Promise<runtime.ApiResponse<Client>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateClient.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/clients/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ConnectionTypeWrapperToJSON(requestParameters.connectionTypeWrapper),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClientFromJSON(jsonValue));
    }

    /**
     * Administrator updates the client information.
     * update security server client information
     */
    async updateClient(requestParameters: UpdateClientRequest): Promise<Client> {
        const response = await this.updateClientRaw(requestParameters);
        return await response.value();
    }

}
